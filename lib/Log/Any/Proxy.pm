package Log::Any::Proxy;
our $VERSION = '1.999_000';
# ABSTRACT: Low-overhead logging that plays well with others

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 SEE ALSO

=cut

use v5.20;
use warnings;

=method new

=cut

sub new {
    my ( $class, @args ) = @_;
    my %self;
    if ( @args == 1 ) {
        %self = %{ $args[0] };
    }
    else {
        %self = @args;
    }
    return bless \%self, $class;
}

=method import

=cut

=method context

=cut

# An array of arrays of ( $caller_id, $context_hash )
# $caller_id is '$filename:$line'
our @context = (
    [ undef, {} ],
);

# XXX: Is context held by a proxy, or global based on the stack?
# Context becomes useless if other proxy objects don't have it: I want
# to set the request ID in my Controller, and then see that request ID
# in any logs generated by my Model.
sub context {
    my $context = $_[0]->_prune_context();
    if ( @_ > 1 ) {
        $context->[-1][1] = {
            %{ $context->[-1][1] },
            @_[1,$#_],
        };
    }
    return defined wantarray ? Log::Any::Proxy->new( context => $context ) : ();
}

sub _get_context {
    my ( $self ) = @_;

    ; use Data::Dumper;
    ; say 'Context stack: ' . Dumper $self->{context} // \@context;

    # Return flattened context
    my $flat_context = { map {; %{ $_->[1] } } @context };
    ; say 'Flattened context: ' . Dumper $flat_context;

    return $flat_context;
}

sub _prune_context {
    my ( $self, $extend ) = @_;

    # Build outside-in stack list
    my @stack;
    my $i = 0;
    # Skip frames inside Log::Any
    $i++ while [ caller $i ]->[0] =~ /^Log::Any/;
    while ( my @caller = caller $i ) {
        unshift @stack, join ':', @caller[1,2];
        $i++;
    }

    ; use Data::Dumper;
    ; say 'Stack: ' . Dumper \@stack;
    ; say 'Context before prune: ' . Dumper \@context;

    # Truncate context stack at first divergence
    $i = 0;
    while ( $i < $#context && $stack[ $i ] eq $context[ $i + 1 ][0] ) {
        $i++;
    }
    ; say "Pruning after $i";
    splice @context, $i + 1;
    ; say 'Context after prune: ' . Dumper \@context;

    if ( $extend ) {
        if ( @stack >= @context ) {
            # Add new frames
            push @context, map [ $stack[ $_ ], {} ], $i..$#stack;
        }

        # Merge with the last frame
        $context[ @stack ][ 1 ] = {
            %{ $context[ @stack ][ 1 ] },
            ref $_[1] eq 'HASH' ? %{ $_[1] } : @_[1..$#_],
        };
        ; say 'Context after extend: ' . Dumper \@context;
    }

    return \@context;
}

# XXX: Can this be here and still allow overriding from the Log::Any
# package?
@Log::Any::LOG_LEVELS = (
    # All-caps are pseudo-levels and do not have methods created
    [qw( OFF )],
    [qw( emergency emerg panic )],
    [qw( alert )],
    [qw( critical crit fatal )],
    [qw( error err )],
    [qw( warning warn )],
    [qw( notice )],
    [qw( info inform )],
    [qw( debug )],
    [qw( trace )],
    [qw( ALL )],
);

# XXX: Something needs to hold on to the current adaptors
our @adaptors;
# XXX: The current lowest log threshold for any adaptor
my $current_log_level = 999;

for my $i ( 0 .. $#Log::Any::LOG_LEVELS ) {
    for my $level ( @{ $Log::Any::LOG_LEVELS[ $i ] } ) {
        # All-caps are pseudo-levels and do not have methods created
        next if $level =~ /^[A-Z]+$/;

        no strict 'refs';
        *{ $level } = sub {
            # If we don't need to tell adaptors about this, just return
            # it so that `die $log->fatal('...');` works correctly.
            return $_[1] if $i > $current_log_level;
            my $context = { %{ $_[0]->context }, %{ ref $_[-1] eq 'HASH' ? pop : {} } };
            ; use Data::Dumper;
            ; say 'Log context: ' . Dumper( $context );
            $_->log( $i, $_[1], $context ) for @adaptors;
            return $_[1];
        };
        *{ "${level}f" } = sub {
            return shift->$level( sprintf( @_ ), ref $_[-1] eq 'HASH' ? pop : () );
        };
    }
}

=method

=cut

1;
